{"meta":{"title":"Goshin's Blog","subtitle":null,"description":null,"author":"John Chong","url":"https://goshin.github.io"},"pages":[{"title":"Categories","date":"2018-01-19T11:31:26.156Z","updated":"2018-01-19T11:31:26.156Z","comments":true,"path":"categories/index.html","permalink":"https://goshin.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-19T11:31:26.156Z","updated":"2018-01-19T11:31:26.156Z","comments":true,"path":"tags/index.html","permalink":"https://goshin.github.io/tags/index.html","excerpt":"","text":""},{"title":"Bilingual Template Test","date":"2018-01-19T13:49:19.000Z","updated":"2018-03-11T01:48:27.905Z","comments":true,"path":"misc/Bilingual-Template-Test/index.html","permalink":"https://goshin.github.io/misc/Bilingual-Template-Test/index.html","excerpt":"Things I didn’t Know about Chrome DevTools This material is originally from 我所不知道的 Chrome 开发者工具 - 开源中国社区. I have been using Firebug as my debugging tool since I started web development. Firebug has been very helpful and the one thing I knew Chrome DevTools has that Firebug doesn’t is performance profiling which helps finding signs of memory leaks on a web page. I have wanted to take the free course Explore and Master Chrome DevTools for a while and I finally cross it out of my to-do list. It took me about four hours to complete the course and I have learned a few cool features of Chrome DevTools that I didn’t know about.","text":"Things I didn’t Know about Chrome DevTools This material is originally from 我所不知道的 Chrome 开发者工具 - 开源中国社区. I have been using Firebug as my debugging tool since I started web development. Firebug has been very helpful and the one thing I knew Chrome DevTools has that Firebug doesn’t is performance profiling which helps finding signs of memory leaks on a web page. I have wanted to take the free course Explore and Master Chrome DevTools for a while and I finally cross it out of my to-do list. It took me about four hours to complete the course and I have learned a few cool features of Chrome DevTools that I didn’t know about. Ways of get a DOM nodeBesides using the magnifier to select the DOM node on the web page, you can use the jQuery style of getting the DOM node with “$” sign. For example, $(“#name”) will give you the DOM node with id as name. If you select a DOM node in the Elements tab, you can then type in “$0″ in the Console tab to get the DOM node. On the other hand, you can type “inspect($0)” in the Console tab to show the DOM node in the Element tab. Show style for different states There is a Toggle Element States option in the Elements -&gt; Styles tab which will open the section for you to set the element state to active, focus, hover, and visited. I found this very helpful to debug the style issue for these states as the style definitions won’t be shown in the Styles tab unless they are in that state. Dynamical editing source files and data source and view the change historyYou can edit CSS files or JavaScript files under the Sources tab. Right click in the file, you will see the option “Local modifications…” to see the change history and revert them. While we are used to editing CSS files, dynamically being able to update JavaScript is very useful. Save updated file locallyThe changes were saved in the Chrome local storage if you edit them in the Sources tab and you can also save the updated files in your computer and override the original ones. Events/Frames view in Timeline The Timeline tab provides three types of views for the recording: Events, Frames, and Memory. The Events/Frames view shows the time spent on HTML parsing(blue), JavaScript rendering(yellow), style calculation(purple), and CSS rendering(green). The memory view is for detecting the sign of memory leaks. Other pluginsPage speed: It’s similar to YSlow. It gives you the suggestions of improving performance. After it’s installed, it’s will be shown as a new tab in the devTools.Google Closure: Compress multiple JavaScript files into one to reduce the number of HTTP requests. Above are just new things that I learned in the class and I enjoyed taking this interactive class. Visit this link for more details about how to improve the performance of your application with Chrome DevTools. 我所不知道的 Chrome 开发者工具 原文来自 我所不知道的 Chrome 开发者工具 - 开源中国社区. 自打我开始进行Web开发后，我就一直将Firebug当作我的调试工具使用。一直以来Firebug对我的帮助非常大，但据我所知，Chrome的开发者工具中有一个功能是Firebug不具有的，它就是性能分析工具，该工具可以帮助我们发现网页中内存泄漏的迹象。我早就想参加一下免费课程Explore and Master Chrome DevTools（探索并掌握Chrome的开发者工具），最后我终于可以把这事从我的待办事项清单中划掉了。这个课程花了我四个小时才学完，我从中学会了Chrome的开发者工具中我以前并不了解的一些非常酷的功能。 获得DOM节点的方法除了可以通过使用放大器在网页中直接选取DOM节点外，你还可以使用jQuery风格的“$”来获得想要的DOM节点。例如，$(“#name”)将会获得id为name的DOM节点。如果你在元素标签中选择了一个DOM节点，你就可以在控制台标签中键入“$0″来获得该DOM节点。另一方面，你在控制台标签中键入“inspect($0)”，就可以转到显示该节点的元素标签中了。 显示不同状态的样式 在元素 –&gt; 样式标签下有个用于切换元素状态的选项，你可以用它将所选元素的状态设置为active（激活）, focus（聚焦）, hover（鼠标悬停）和visited（已访问过）。我发现这个对于调试这些状态的样式问题帮助非常大，因为在样式标签下只显示当前状态下的样式定义。 动态编辑源文件和数据源并查看修改的历史记录你可以在源文件标签下修改CSS文件或者JavaScript文件。鼠标右键点击文件，你将看到有个“本地修改。。。”这个菜单，单击该菜单你就能看到该文件的修改历史记录并可以对它们进行恢复操作。尽管我们已经习惯了编辑CSS文件，但能够动态的更新JavaScript用处可大了。 将更新的文件保存到本地如果你在源文件标签中对文件进行了修改，Chrome会将这些修改保存到它的本地存储之中。你也可以将修改后的文件保存到你的计算机之中并用它们覆盖原先的文件。 时间线中的事件/帧视图 时间线标签为Chrome所记录下来的内容提供三种类型的视图: 事件、帧和内存 The 事件/帧视图显示的是花在HTML解析（蓝色部分）、JavaScript渲染(黄色部分)、样式计算(紫色)以及CSS渲染(绿色)等方面的时间。内存视图是用来寻找内存泄漏的迹象的。 其它插件页面速度（Page speed）：它同YSlow类似，可以在提高性能方面为你提出一些建议。安装完成后，它会作为开发者工具中的一个新标签显示出来。Google Closure：将多个JavaScript文件压缩为一个文件，以减少HTTP请求的个数。 上面只是我从这个课程中学到的一些新东西。我非常乐于参加这个交互式课程。想要了解更多关于如何通过使用Chrome的开发者工具来提高你的应用的性能的细节，请访问这个链接。"}],"posts":[{"title":"Hexo 下实现双语双栏对照模板","slug":"Bilingual-Template-in-Hexo","date":"2018-01-19T14:46:29.000Z","updated":"2018-03-11T08:48:29.021Z","comments":true,"path":"2018/01/19/Bilingual-Template-in-Hexo/","link":"","permalink":"https://goshin.github.io/2018/01/19/Bilingual-Template-in-Hexo/","excerpt":"在 Hexo 中如果博客有双语写作的需求，其自带的国际化功能中通常的实践是为每一篇文章和主题模板都撰写对应的多语言副本，生成后通过点击链接进行整站语言切换。 如果只是有零星几篇双语文章，这样的成本未免有些大了，之前看到过翻译文章双栏对照的排版，觉得非常适合双语对照展示的场景，但 Google 一圈后并没有发现 Hexo 下有现成的模板，因此自己动手实现一下，顺便可以学习下 Hexo 模板的开发。 文章布局 LayoutHexo 在创建新文章的时候可以指定文章的布局 layout，在生成时 Hexo 会调用主题 layout 目录下的对应 layout 文件进行文章的渲染。 1$ hexo new [layout] &lt;title&gt; # 或新建后在文档中指定 layout 项","text":"在 Hexo 中如果博客有双语写作的需求，其自带的国际化功能中通常的实践是为每一篇文章和主题模板都撰写对应的多语言副本，生成后通过点击链接进行整站语言切换。 如果只是有零星几篇双语文章，这样的成本未免有些大了，之前看到过翻译文章双栏对照的排版，觉得非常适合双语对照展示的场景，但 Google 一圈后并没有发现 Hexo 下有现成的模板，因此自己动手实现一下，顺便可以学习下 Hexo 模板的开发。 文章布局 LayoutHexo 在创建新文章的时候可以指定文章的布局 layout，在生成时 Hexo 会调用主题 layout 目录下的对应 layout 文件进行文章的渲染。 1$ hexo new [layout] &lt;title&gt; # 或新建后在文档中指定 layout 项 因此首先需要在 theme 中新建一个 layout 文件，可以从原有模板的文章默认 layout 复制一份作为基础对其进行修改。比如我这里复制后的路径是 themes/icarus/layout/bil-post.ejs 。 这样以后新建双栏对照文章只需： 1$ hexo new bil-post &lt;title&gt; 接着修改复制得到的 layout，将原本引入文章文本的地方： 1&lt;%- post.content %&gt; 修改为： 123456789&lt;% post.column = post.content.split('&lt;!--second-column--&gt;') %&gt;&lt;div class=\"article-bil-column bil-first-column\"&gt; &lt;%- post.column[0] %&gt;&lt;/div&gt;&lt;div class=\"article-bil-column bil-second-column\"&gt; &lt;%- post.column[1] %&gt;&lt;/div&gt;&lt;%- css('css/bilingual') %&gt;&lt;%- js('js/bilingual') %&gt; 这里将文章文本内容按标记 &lt;!--second-column--&gt; 分割，放在左右两栏的两个 div 中，再引入样式和脚本。 接着新建一个样式文件 themes/icarus/source/css/bilingual.styl，定义两栏的样式： 12345678.article-bil-column display: inline float: left width: calc(50% - 10px) /* 每栏各占宽 50%， 边界预留 10px 空白 */ &amp;.bil-first-column padding: 0 10px 0 0 &amp;.bil-second-column padding: 0 0 0 10px 这样两栏就可以并排显示了。 同步滚动实现双栏并排显示后还有一个问题需要解决。两种语言下的同一段话字数往往不同，所占用的版面行数会有所差距，篇幅一长两边便对应不上，影响对照的效果。因此需要两边内容上的同步滚动。 实现同步滚动有两种思路，第一种可以考虑令两边对应段落高度保持一致，略微扩充其中较短的一段，这种方式实现比较简单，但要求两边段落数量一致。第二种方式给每一段添加锚点标记，在页面滚动时，用 JS 控制一组锚点位置对齐，滚动效果很酷炫，但实现较为复杂，且需要额外考虑一些兼容问题。这里先选择实现第一种。 新建 themes/icarus/source/js/bilingual.js： 123456789101112131415161718192021222324252627282930313233343536373839(function($) &#123; var leftParagraphs = $('.article-entry .bil-first-column').find('p, h1, h2, h3, h4, h5, h6'); var rightParagraphs = $('.article-entry .bil-second-column').find('p, h1, h2, h3, h4, h5, h6'); var align = () =&gt; &#123; /* 如果页面宽度大于 800px，进行段落对齐，见下一节 */ if(window.matchMedia('(min-width: 800px)').matches) &#123; leftParagraphs.each((i, thiz) =&gt; &#123; var left = $(thiz); var right = rightParagraphs.eq(i); left.removeAttr('style'), right.removeAttr('style'); /* 取对应两段高度的最大值 */ var maxHeight = Math.max(left.height(), right.height()); left.height(maxHeight), right.height(maxHeight); &#125;); &#125; else &#123; leftParagraphs.removeAttr('style'), rightParagraphs.removeAttr('style'); &#125; &#125; if(leftParagraphs.size() == rightParagraphs.size()) &#123; var resizeHandler = 0; /* 监听窗口大小变化 */ $(window).resize(() =&gt; &#123; if(resizeHandler) &#123; clearTimeout(resizeHandler); &#125; resizeHandler = setTimeout(align, 50); &#125;); if($('#main img').size()) &#123; $('#main img').load(align); &#125; else &#123; $(align); &#125; &#125;&#125;)(jQuery); 响应式布局在手机等屏幕较小的设备中，如果保持双栏显示会使正文栏变得很窄而影响阅读，解决办法是根据设备对布局做自适应处理，在屏幕宽度受限的情况下单栏平铺显示。 CSS 提供了媒体查询的接口，可用于为不同宽度的设备设置不同的样式，我使用的主题也定义了一些媒体类型的变量，因此只需在上面定义的样式基础上稍加扩展即可： 123456789101112131415161718192021@import \"_variables\".article-bil-column display: inline float: left @media mq-normal width: calc(50% - 10px) &amp;.bil-first-column padding: 0 10px 0 0 &amp;.bil-second-column padding: 0 0 0 10px @media mq-tablet width: calc(50% - 10px) &amp;.bil-first-column padding: 0 10px 0 0 &amp;.bil-second-column padding: 0 0 0 10px @media mq-mobile width: 100% @media mq-mini width: 100% 再根据所使用主题的需要，加上对页面的其他元素的调整： 1234567891011#main width: 100%/* 隐藏侧边信息卡片 */aside#profile display: none /* 平铺右边文章列表栏 */aside#sidebar display: block width: 100%; 效果： Demo Bilingual Template Test","categories":[{"name":"Front-End","slug":"Front-End","permalink":"https://goshin.github.io/categories/Front-End/"}],"tags":[{"name":"Front-End, Hexo","slug":"Front-End-Hexo","permalink":"https://goshin.github.io/tags/Front-End-Hexo/"}],"keywords":[{"name":"Front-End","slug":"Front-End","permalink":"https://goshin.github.io/categories/Front-End/"}]},{"title":"Android 响应式编程的未来展望：RxJava 2 版本前瞻","slug":"The-Next-Step-for-Reactive-Android-Programming","date":"2017-01-18T05:53:25.000Z","updated":"2018-01-19T11:31:26.132Z","comments":true,"path":"2017/01/18/The-Next-Step-for-Reactive-Android-Programming/","link":"","permalink":"https://goshin.github.io/2017/01/18/The-Next-Step-for-Reactive-Android-Programming/","excerpt":"原文地址：The Next Step for Reactive Android Programming 原文作者：Tomek Polański 译文出自：掘金翻译计划 译者：Goshin 校对者：tanglie1993, jamweak 下一代的 RxJava 已经发布：RxJava 2。如果你现在的工作项目使用 RxJava 1，现在可以选择迁移至新版本。但我们是应该马上动手迁移，还是应该等待一段时间，先做些项目的其他工作？ 要做出这个决定，你需要仔细考虑一下「投资回报（ROI）」，想想花费时间进行迁移能否在短期或长期内得到回报。","text":"原文地址：The Next Step for Reactive Android Programming 原文作者：Tomek Polański 译文出自：掘金翻译计划 译者：Goshin 校对者：tanglie1993, jamweak 下一代的 RxJava 已经发布：RxJava 2。如果你现在的工作项目使用 RxJava 1，现在可以选择迁移至新版本。但我们是应该马上动手迁移，还是应该等待一段时间，先做些项目的其他工作？ 要做出这个决定，你需要仔细考虑一下「投资回报（ROI）」，想想花费时间进行迁移能否在短期或长期内得到回报。 迁移的好处响应流的兼容性RxJava 2 其中一个结构性变化就是增加了对响应流（Reactive Streams） 的兼容性。为此，RxJava 只能从头开始重写。 响应流为描述响应式编程库该如何运作提供了一种共同的理解和通用的 API。 我们大多数人并不编写响应式编程库，但相同的 API 可以让我们能够同时使用不同的响应式编程库。 其中一个例子就是 Reactor 3 库，这个库很像 RxJava。如果你是个 Android 开发者，可能没怎么跟它打过交道，因为它只支持 Java 8 及以上版本。 但不管怎样，现在在这两个库之间转换响应流可以像下面这样简单： 绿色代码是 RxJava 2，红色代码是 Reactor 3 Reactor 3 相较 RxJava 2 有 10% 至 50% 的性能提升，但遗憾的是不能用在 Android 上。 据我所知 RxJava 2 现在是唯一一个 Android 上支持响应流的库。也就是说，现如今为了响应流而使用 RxJava 2 意义并不大。 负载压力处理 - Observable/FlowableRxJava 2 新增了一种响应式类型：Flowable，它跟 RxJava 1 中的 Observable 很相似，关键区别在于 Flowable 类型支持负载压力（backpressure）处理。 首先明确一下什么是「支持负载压力处理」。 刚接触 RxJava 2 的开发者经常会听到「Flowable 支持负载压力处理」，想问：「支持负载压力处理就是说我不会遇到 MissingBackpressureException 是吗？」但答案是否定的。 支持负载压力处理就是说当事件消费者的处理能力不能负载源源不断的事件输入时，它可以指定一种策略来处理这些事件。 Flowable在使用 Flowable 的情况下，你需要指明如何处理这种过载情况，包括以下几种策略： 缓存 - 对于消费者不能马上开始处理的事件，RxJava 会把它们缓存起来，等到消费者处理完先前事件时重新输入给消费者。 丢弃 - 如果消费者事件处理过慢，它会忽略所有新的到达事件，并在完成当前事件的处理后从最近的一个输入事件开始处理。 错误 - 消费者将会抛出 MissingBackpressureException。 在实际情况中，在我们的应用中会遇到负载压力吗？我也很好奇，所以编写了一个调用加速度传感器的 Flowable 例子，读取传感器数据并显示在屏幕上。 利用 Flowable 的加速度计 这个 Android 加速度计每秒处理大概 50 次数据读取，而这种频率下的数据显示尚不足以发生负载过重的情况。当然这取决于响应式序列中的每个事件的处理负荷，但也足以说明负载压力并不会经常出现。 ObservableObservable 不支持负载压力处理，这意味着 Observable 不会抛出 MissingBackpressureException。如果消费者不能马上处理事件，事件会被缓存起来等待重新输入。 那么我们什么时候该用 Flowable，什么时候又该用 Observable 呢？ 在可能会出现负载压力且需要仔细处理对待的时候，我会选择 Flowable。例如上面的加速度计，我仍会使用 Flowable。因为如果我在读取传感器数据时需要额外做一些处理，而不是仅仅把它们显示出来，就有可能出现负载压力。 如果不太可能出现这种情况，应该选择 Observable。用户在一小段时间内点击多次按钮时，把这些事件进行缓存处理也是可以接受的。 不过要注意，使用 Observable 时，如果缓存了过多事件，整个应用会因此崩溃。 我的经验是，在创建 Observable 时，考虑事件源是否对应以下情形： 用户点击按钮，每秒最多数个事件，使用 Observable。 光线传感器或加速度传感器，每秒几十个事件，使用 Flowable。 记住：就算是点击按钮，如果每次处理耗时很长，也会出现负载压力！ 性能表现RxJava 2 的性能表现要优于上个版本的 RxJava 1. 可以用更高性能的库总是好事情。但是，只有当前性能瓶颈在于 RxJava 时，你才能看到明显的提升。 那你又是否曾经面对代码，抱怨「flatMap 实在是太慢了」？ 对于一个 Android 应用，计算性能往往不成问题。在多数情况下，UI 渲染才是瓶颈所在。 发生丢帧不是因为有太多计算任务，而是因为布局太过复杂、没有把文件操作放在后台线程，或是在 onDraw 中创建 bitmap 等错误。 迁移带来的挑战跟 Null 说再见近年来对于 null 的抵制愈演愈烈，这并不奇怪，即使是 Null 引用的发明者也把它称为是「导致 10 亿美元损失的错误」。 在 RxJava 1 中你还可以使用 null 值。但在新版本，流序列中 null 值的使用会被完全禁止，你将不能再继续使用 null。如果你在当前项目中正使用着 null 值，请做好进行大量改写工作的准备。 你需要寻求一些其他方式，例如空对象模式或是 Optional 对象，来表示空值。 Dex 限制你有试过向函数式编程开发者解释「在 Android ，实际上函数的数量存在限制」吗？你可以试试，他们的反应会很有趣。 很遗憾，的确存在这个我们都尽量避免的 65000 个方法的数量限制。（译者注：如果方法超出这个数量，Java 字节码将需要分开存放在两个或多个 Dex 中。这个分割过程可以自动完成，一般无需干预，但在特定场景下，可能会引发问题。）RxJava 1 有大概 5500 个方法，数量不少。而现在 RxJava 2 则有超过 9200 个方法。这 4000 方法数量的增加相较于新增的功能来说还算是可以接受的，但在你逐步迁移的过程中，你也许会需要两个版本的库同时并存。 那么总共差不多就是 15000 个方法，已经占到了 Dex 限制的 22%！ 注意以上方法数量的预估未考虑 Proguard 的压缩处理，所以实际中还可以省下几千个方法。 如果你早已经超出了这个限制，则不用担心这个问题。 但如果是十分接近的情况，则要在迁移过程中多加留意是否会超出 Dex 限制。 编写操作符 RxJava 现有的操作符（Operator）可能不能满足你的需要。要实现一些自定义的行为机制，你也许会考虑自己编写操作符。 现在，给 RxJava 2.x 编写操作符要比给 1.x 编写难上 10 倍。 Dávid Karnok 在 RxJava 1 时这也不是一件易事。你需要考虑多线程并发访问和对负载压力的处理支持。 到 RxJava 2 情况变得更加复杂。第一，创建操作符的方式已经改变，不再使用之前饱受诟病的创建方法。而且在 RxJava 2 中，除了多线程并发访问，负载压力处理，消除机制（cancellation）等麻烦问题，你还要考虑用上第四代特性，例如操作符融合（Operator Fusion），来提高操作符的性能。但这同时也增加了编写操作符的复杂性。 那么自己编写自定义操作符值得吗？ 除非你是想为 RxJava 2 或其他响应式库贡献代码，否则我都建议用其他方法解决问题。 首先看看能不能通过现有操作符的组合使用来解决问题。或者你可以考虑编写一个转换器（transformer）。虽然不能像操作符那样高度可定制，但相对而言要容易编写得多。虽然使用操作符还有另一个提升性能的好处，但如上文所述，这种性能提升在 Android 中有很大可能会被浪费或掩盖，因为瓶颈往往在 UI 方面。 如果你仍想编写一个自定义操作符，可以对照一下最简单的操作符（map），和一个最复杂的操作符（flatMap），看看你是否要应对挑战。 总结以上就是升级到 RxJava 2 带来的主要好处与挑战。但要判断迁移是否值得总得根据你的实际情况而定。 就目前来说，停留在 RxJava 1 十分不错，它仍受开发团队维护和支持。在不久之后，当 RxJava 开发团队不再维护而选择弃用 RxJava 1，届时你也会有更加充分的理由升级到 RxJava 2。 如果你的项目要持续一年以上，你可能需要考虑迁移事宜，否则停留在 RxJava 1 是更好的选择。 如果你对如何迁移感兴趣，请留意我（原作者）的下一篇文章。","categories":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://goshin.github.io/tags/Java/"},{"name":"Reactive","slug":"Reactive","permalink":"https://goshin.github.io/tags/Reactive/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/categories/Android/"}]},{"title":"使用 Xposed 进行黑盒测试","slug":"Black-box-test-using-Xposed","date":"2016-07-14T04:02:08.000Z","updated":"2018-01-19T11:31:26.128Z","comments":true,"path":"2016/07/14/Black-box-test-using-Xposed/","link":"","permalink":"https://goshin.github.io/2016/07/14/Black-box-test-using-Xposed/","excerpt":"现在的 Android App 在编译发行时，一般都会混淆代码，或者加密保护 dex，虽然能够有效防止打包客反编译修改后重新发行，但也给我们个人学习 Dalvik 指令和理解程序逻辑带来了很大麻烦。在做静态分析时，面对茫茫一片混淆后无规则的类名，往往难以下手，只能停留在一些 APP 的常见入口，无法继续深入。 Xposed 是 Android 上非常有名的一个 hook 框架。通过 Xposed，可以轻松勾住 Java 层的所有方法。hook 的应用非常广泛，包括资源替换、系统优化、性能分析等，下面就与大家分享一下我利用 Xposed 分析混淆代码应用的一些心得。","text":"现在的 Android App 在编译发行时，一般都会混淆代码，或者加密保护 dex，虽然能够有效防止打包客反编译修改后重新发行，但也给我们个人学习 Dalvik 指令和理解程序逻辑带来了很大麻烦。在做静态分析时，面对茫茫一片混淆后无规则的类名，往往难以下手，只能停留在一些 APP 的常见入口，无法继续深入。 Xposed 是 Android 上非常有名的一个 hook 框架。通过 Xposed，可以轻松勾住 Java 层的所有方法。hook 的应用非常广泛，包括资源替换、系统优化、性能分析等，下面就与大家分享一下我利用 Xposed 分析混淆代码应用的一些心得。 如何 hookXposed 替换了 app_process (Zygote)，将 Java 方法改为 Native 方法骗过虚拟机，从而拿到 Java 方法的代理权。所以首先得明白，Xposed 只能 hook Java 方法。虽然原理很复杂，但是 Xposed 提供给 module 开发者的 API 还是很简单方便的，请参考 Xposed repo 上的指导和完整的 API 文档，常见的使用如： 12345678910111213/* Hook org.apache.http 包中的 HttpPost 请求 */XposedHelpers.findAndHookMethod(\"org.apache.http.impl.client.AbstractHttpClient\", loadPackageParam.classLoader, \"execute\", HttpUriRequest.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; if (!param.args[0].getClass().getCanonicalName().contains(\"HttpPost\")) &#123; return; &#125; HttpPost request = (HttpPost) param.args[0]; String url = request.getURI().toString(); &#125;&#125; Xposed 通过 Java 虚拟机的反射 API来找目标类和方法，所以要注意你只能 hook 具体实现的方法，除此之外，交由子类实现的抽象方法、在子类中被重写且没有被调用的父类方法、和继承自父类但没有重写的子类方法，是不能 hook 的。虽然 Dalvik 有 invoke-virtual 指令，但实际虚拟机中对象的每个方法都是独立唯一的，与父类的方法没有链式调用的关系（，不过对象的构造方法和显式调用 super() 除外）。 举一个实际中的例子，比如说你想 hook java.net.HttpURLConnection 的 getInputStream() 方法，来做一些流量统计或者内容嗅探等工作。一般来说是这样写的： 12345678/* 错误示范 */XposedHelpers.findAndHookMethod(\"java.net.HttpURLConnection\", loadPackageParam.classLoader, \"getInputStream\", new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; /* Do something */ &#125;&#125; 但这样会报错，Xposed 日志会显示找不到该方法。根据文档，这个 getInputStream() 方法是继承自它的父类 java.net.URLConnection 的方法，在 java.net.HttpURLConnection 中并没有重写。但如果将上面的目标类改成 java.net.URLConnection 依然会 hook 失败。原因请看下面 java.net.URLConnection 中 getInputStream() 部分的源码： 123456789101112/** * Returns an &#123;@code InputStream&#125; for reading data from the resource pointed by * this &#123;@code URLConnection&#125;. It throws an UnknownServiceException by * default. This method must be overridden by its subclasses. * * @return the InputStream to read data from. * @throws IOException * if no InputStream could be created. */public InputStream getInputStream() throws IOException &#123; throw new UnknownServiceException(\"Does not support writing to the input stream\");&#125; 可以看出基类 java.net.URLConnection 并没有实现这个方法。在实际中，HTTP 请求的处理是由系统 framework 层中一些平台相关的实现类来具体实现的。 所以应该 hook 实现类中的方法，具体如下。 123456789final int apiLevel = Build.VERSION.SDK_INT;/* 自 Android 4.4 后改用 okhttp 实现，在 6.0 后包名有改动 */if (apiLevel &gt;= 23) &#123; XposedHelpers.findAndHookMethod(\"com.android.okhttp.internal.huc.HttpURLConnectionImpl\", loadPackageParam.classLoader, \"getInputStream\", URLGetInputStreamHook);&#125; else if (apiLevel &gt;= 19) &#123; XposedHelpers.findAndHookMethod(\"com.android.okhttp.internal.http.HttpURLConnectionImpl\", loadPackageParam.classLoader, \"getInputStream\", URLGetInputStreamHook);&#125; else &#123; XposedHelpers.findAndHookMethod(\"libcore.net.http.HttpURLConnectionImpl\", loadPackageParam.classLoader, \"getInputStream\", URLGetInputStreamHook);&#125; Hook 系统 API你可以 hook 一些敏感的系统 API，打印出参数和返回结果，从而获取到一些关键信息。 比如说 HTTP 请求中的 payload、startActivity() 中传递的 Intent，块加密的密钥等敏感内容。 12345678910XposedHelpers.findAndHookConstructor(\"java.net.URL\", loadPackageParam.classLoader, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; String url = (String) param.args[0]; log(\"URL construct \" + url); /* 还可以通过修改参数或结果，改变应用逻辑 */ param.args[0] = \"http://www.baidu.com/\"; log(\"Change URL to \" + param.args[0]); &#125;&#125;); 打印栈跟踪信息新建一个 Exception，把当前应用方法调用的栈跟踪信息打印出来。对于混淆后的代码，这招相当有用，可以快速定位反汇编后的关键点，理清类之间调用关系，对理解程序的逻辑很有帮助。 123456789XposedHelpers.findAndHookConstructor(\"java.net.URL\", loadPackageParam.classLoader, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; /* 打印调用栈跟踪信息 */ new Exception(\"new URL\").printStackTrace(); /* 记录到 Xposed 日志 */ XposedBridge.log(new Exception(\"new URL\")); &#125;&#125;); Hook 异常信息应用运行过程中产生的异常往往包含了一些重要信息，而这些异常通常会被捕获且不会将异常 log 内容打印出来。这时就可以通过 Xposed 来 hook 异常的构造方法，得到异常跟踪信息。Java 的异常类通过继承来实现异常的层级化归类，且子类在构造时会调用父类的构造方法，所以我们可以通过 hook 异常基类来实现对一大类异常的捕获，如： 1234567XposedBridge.hookAllConstructors(IOException.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; /* 所有网络 IO，本地 IO 等 IO 错误都会被捕获 */ XposedBridge.log((Throwable) param.thisObject); &#125;&#125;); 最后暂时先记录这么多，以后有想起什么再另行补充，欢迎大家留言指正。","categories":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://goshin.github.io/tags/Java/"},{"name":"Xposed","slug":"Xposed","permalink":"https://goshin.github.io/tags/Xposed/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://goshin.github.io/categories/Android/"}]},{"title":"【译】如何应用最新版的谷歌表格 API","slug":"using-new-google-sheets-api","date":"2016-06-27T14:45:55.000Z","updated":"2018-01-19T11:31:26.156Z","comments":true,"path":"2016/06/27/using-new-google-sheets-api/","link":"","permalink":"https://goshin.github.io/2016/06/27/using-new-google-sheets-api/","excerpt":"原文链接 : Using the new Google Sheets API 原文作者 : WESLEY CHUN 译文出自 : 掘金翻译计划 译者 : Goshin 校对者: warcryDoggie, jkjk77 引言本文将演示如何使用最新的 Google 表格 API. Google 在 2016 I/O 大会上发布了第四版的表格 API（博客，视频），与之前版本相比，新版增加了大量功能。现在，你可以通过 API v4 完成 Google 表格移动版和桌面版的大部分操作。 文章下面会通过 Python 脚本，一步步将一个玩具公司关系型数据库里的客户订单数据逐条读出，并写到一个 Google 表格中。其他会涉及到的 API 还有：新建 Google 表格、从表格中读取数据。 在之前的几篇文章中，我们已经介绍了 Google API 的结构和大致的使用说明，所以近期的文章会关注特定 API 在实际问题中的使用方法。如果你已经阅读过之前那篇，便可以从下面的授权范围开始，了解具体如何使用。","text":"原文链接 : Using the new Google Sheets API 原文作者 : WESLEY CHUN 译文出自 : 掘金翻译计划 译者 : Goshin 校对者: warcryDoggie, jkjk77 引言本文将演示如何使用最新的 Google 表格 API. Google 在 2016 I/O 大会上发布了第四版的表格 API（博客，视频），与之前版本相比，新版增加了大量功能。现在，你可以通过 API v4 完成 Google 表格移动版和桌面版的大部分操作。 文章下面会通过 Python 脚本，一步步将一个玩具公司关系型数据库里的客户订单数据逐条读出，并写到一个 Google 表格中。其他会涉及到的 API 还有：新建 Google 表格、从表格中读取数据。 在之前的几篇文章中，我们已经介绍了 Google API 的结构和大致的使用说明，所以近期的文章会关注特定 API 在实际问题中的使用方法。如果你已经阅读过之前那篇，便可以从下面的授权范围开始，了解具体如何使用。 Google 表格 API 授权认证及权限范围之前版本的 Google Sheets API（早期名为 Google Spreadsheets API）作为 GData API 组 的一部分，与其他 API 一起构建实现了较不安全的 Google Data (GData) 协议，以一种 REST 驱动的技术方式读写网络中的信息。而新版表格 API 已成为 Google APIs 中的一员，使用 OAuth2 方式认证，且利用 Google APIs 客户端库 降低了使用难度。 目前 API 提供两种授权范围：只读和读写。一般建议开发者根据用途尽量选择较多限制的授权范围。这样可以向用户请求较少的权限，用户更乐意一些，而且这样会令你的应用更加安全，防止可能的数据破坏，并可以预防流量及其他配额不经意地超出。在这个例子中我们需要创建表格并写入数据，所以必须选择『读写』授权。 参考文档 - 权限部分：读写表格数据及表格属性 使用 Google 表格 API开始代码部分的讲解：从 SQLite 数据库读取记录，根据这些数据新建 Google 表格。 之前的文章和视频中已经包含了授权的完整例子，所以这里直接从创建表格的调用点开始。调用 apiclient.discovey.build() 函数，并传入 API 名字符串 &#39;sheets&#39; 和版本号字符串 &#39;v4&#39;。 1SHEETS = discovery.build('sheets', 'v4', http=creds.authorize(Http())) 有了表格服务的调用点，首先要做的就是新建一个空白的 Google 表格。在此之前，你需要知道一点：大多数的 API 调用都需要传入一个包含操作名和数据的 JSON 请求主体，随着使用的深入，你会越来越熟悉这一点。对于新建表格来说，JSON 主体就比较简单，不需要加入任何值，传进一个空的 dict 就行，但最好还是提供一个表格的名字，参照下面这个 data： 1data = &#123;'properties': &#123;'title': 'Toy orders [%s]' % time.ctime()&#125;&#125; 注意表格的标题 “title” 是它属性 “properties” 的一部分，另外这里还给名字加上了当前的时间戳。完成主体的构建后，将其传入 spreadsheets().create() 并执行，完成空白表格的创建。 1res = SHEETS.spreadsheets().create(body=data).execute() 另外，你还可以通过 Google Drive API (v2 或 v3) 来新建表格，但还需要传入 Google 表格（文件）的 MIME 类型: 12345data = &#123; 'name': 'Toy orders [%s]' % time.ctime(), 'mimeType': 'application/vnd.google-apps.spreadsheet',&#125;res = DRIVE.files().create(body=data).execute() # insert() for v2 一般来说如果你只需要进行表格的操作，那仅表格的 API 就已足够。但如果你还需要创建其他文件，或是操作其他 Drive 文件和文件夹，你才需要 Drive API。当然如果你的应用复杂，你也可以都用，或是结合其他 Google API 使用。但这里就只用到表格 API。 新建完表格后，获取并显示一些信息。 12SHEET_ID = res['spreadsheetId']print('Created \"%s\"' % res['properties']['title']) 你也许会问：为什么要先新建表格然后再另外调用 API 添加数据？为什么不能在新建表格的时候同时添加数据？这个问题的答案虽然是可以，但是这样做意味着你需要在创建表格的时候，构建一个包含整张表格所有单元格数据及其格式的 JSON，而且单元格的格式数据相当繁复，结构并不像一个数组这么简单（当然你可以尽管尝试）。所以才有了 spreadsheets().values() 的一系列相关函数，来简化仅针对表格数据的上传和下载。 现在再看看 SQLite 数据库文件（db.sqlite） 读写部分，你可以从 Google 表格 Node.js 代码实验 处获取该文件。下面的代码通过 sqlite3 标准库来连接数据库，读取所有记录，添加表头，并去除最后两列时间戳： 12345678FIELDS = ('ID', 'Customer Name', 'Product Code', 'Units Ordered', 'Unit Price', 'Status', 'Created at', 'Updated at')cxn = sqlite3.connect('db.sqlite')cur = cxn.cursor()rows = cur.execute('SELECT * FROM orders').fetchall()cxn.close()rows.insert(0, FIELDS)data = &#123;'values': [row[:6] for row in rows]&#125; 拿到表格主体（由记录组成的数组）后，调用 spreadsheets().values().update()，比如： 12SHEETS.spreadsheets().values().update(spreadsheetId=SHEET_ID, range='A1', body=data, valueInputOption='RAW').execute() 除了表格 ID 和数据主体之外，这个 API 调用还需要另外两个参数字段：一个是写入表格中的单元格位置范围（这里是左上角，记为 A1）。另一个是值的输入选项，用来定义数据该如何处理：是作为原始值（”RAW”），或用户输入值（”USER_ENTERED”），还是转换成字符串、数字。 从表格中读取行数据就比较简单，spreadsheets().values().get() 只需要传入表格 ID 和读取单元格的范围。 12345print('Wrote data to Sheet:')rows = SHEETS.spreadsheets().values().get(spreadsheetId=SHEET_ID, range='Sheet1').execute().get('values', [])for row in rows: print(row) 如果成功的话，会返回一个包含 &#39;values&#39; 键的 dict。get() 的默认值是一个空数组，这样在失败时，for 循环也不会出错。 如果你成功运行（末尾有附完整代码），并在浏览器 OAuth2 授权弹窗中同意 Google 表格修改权限的申请，你应该可以得到以下输出： 12345678$ python3 sheets-toys.py # or python (2.x)Created \"Toy orders [Thu May 26 18:58:17 2016]\" with this data:['ID', 'Customer Name', 'Product Code', 'Units Ordered', 'Unit Price', 'Status']['1', \"Alice's Antiques\", 'FOO-100', '25', '12.5', 'DELIVERED']['2', \"Bob's Brewery\", 'FOO-200', '60', '18.75', 'SHIPPED']['3', \"Carol's Car Wash\", 'FOO-100', '100', '9.25', 'SHIPPED']['4', \"David's Dog Grooming\", 'FOO-250', '15', '29.95', 'PENDING']['5', \"Elizabeth's Eatery\", 'FOO-100', '35', '10.95', 'PENDING'] 总结下面是完整脚本，兼容 Python2 和 Python3。 123456789101112131415161718192021222324252627282930313233343536373839404142'''sheets-toys.py -- Google Sheets API demo created Jun 2016 by +Wesley Chun/@wescpy'''from __future__ import print_functionimport argparseimport sqlite3import timefrom apiclient import discoveryfrom httplib2 import Httpfrom oauth2client import file, client, toolsSCOPES = 'https://www.googleapis.com/auth/spreadsheets'store = file.Storage('storage.json')creds = store.get()if not creds or creds.invalid: flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args() flow = client.flow_from_clientsecrets('client_id.json', SCOPES) creds = tools.run_flow(flow, store, flags)SHEETS = discovery.build('sheets', 'v4', http=creds.authorize(Http()))data = &#123;'properties': &#123;'title': 'Toy orders [%s]' % time.ctime()&#125;&#125;res = SHEETS.spreadsheets().create(body=data).execute()SHEET_ID = res['spreadsheetId']print('Created \"%s\"' % res['properties']['title'])FIELDS = ('ID', 'Customer Name', 'Product Code', 'Units Ordered', 'Unit Price', 'Status', 'Created at', 'Updated at')cxn = sqlite3.connect('db.sqlite')cur = cxn.cursor()rows = cur.execute('SELECT * FROM orders').fetchall()cxn.close()rows.insert(0, FIELDS)data = &#123;'values': [row[:6] for row in rows]&#125;SHEETS.spreadsheets().values().update(spreadsheetId=SHEET_ID, range='A1', body=data, valueInputOption='RAW').execute()print('Wrote data to Sheet:')rows = SHEETS.spreadsheets().values().get(spreadsheetId=SHEET_ID, range='Sheet1').execute().get('values', [])for row in rows: print(row) 你可以根据你的需要修改定制这段代码，改成移动前端脚本、开发脚本、后端脚本，或是使用其他 Google API。如果你觉得例子太过复杂，可以看看这篇只涉及读取现有表格的快速入门 Python 部分。如果你熟悉 JavaScript，想做点更正式的东西，可以了解一下这个 Node.js 上手表格 API 代码实验，即上文中获取数据库文件的地方。本文就写到这里，希望能在最新表格 API 的入门了解上对你有所帮助。 附加题: 请自由尝试单元格格式化及其他 API 的功能。除了读写数值，API 还有很多功能，挑战一下你自己吧！","categories":[{"name":"Python","slug":"Python","permalink":"https://goshin.github.io/categories/Python/"}],"tags":[{"name":"Google","slug":"Google","permalink":"https://goshin.github.io/tags/Google/"},{"name":"Google API","slug":"Google-API","permalink":"https://goshin.github.io/tags/Google-API/"},{"name":"Google Sheets","slug":"Google-Sheets","permalink":"https://goshin.github.io/tags/Google-Sheets/"},{"name":"Python","slug":"Python","permalink":"https://goshin.github.io/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://goshin.github.io/categories/Python/"}]}]}